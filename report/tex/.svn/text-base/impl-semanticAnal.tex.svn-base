\section{Semantic Analysis}
During the semantic analysis, we check our scope rules and save all the variables found in the environment. This environment is used during execution for accessing the values of all game variables, character variables, and globals alike.
The following section explains how we perform the semantic analysis in KAPAOOW.

\subsection*{Environment}
The environment is responsible for keeping track of the value of all variables available in the game.

\begin{figure}[H]
\centering
\includegraphics[scale=0.25]{img/environment.png}
\caption{The variable environment class}
\label{fig:environment}
\end{figure}

The node pointers is used to point to where the \textsf{Start}, \textsf{Turn begins}, \textsf{Turn ends}, \textsf{Characters} and \textsf{Attack types} nodes are, so that it is not necessary to find them again when they are needed. The \textsf{Turn begins/ends} nodes are used regularly between each players turn, while the \textsf{Start} block is used whenever the game has to be restarted. Characters are similarly used when restarting, in the case that the players want to play with different characters, it is needed to read the correct character variables into the "Player" class.
The variable lists are global variables and scope specific variables. For example a variable defined in the \textsf{Start} block would be placed in the globals list, since all variables in the root of the \textsf{Start} block is global, while a variable declared in an action (in a character) would be placed in the scope specific.
\textsf{player} and \textsf{enemy} are used to point to the \textsf{player1} and \textsf{player2} objects, and is swapped whenever a participant's turn has been finished.

\begin{figure}[H]
\centering
\includegraphics[scale=0.25]{img/player.png}
\caption{The player class}
\label{fig:player}
\end{figure}

The "Player" class is a class responsible for keeping track of variables and other important aspects of \textbf{one} player.
The node pointers are to the players \textsf{Turn Begins} and \textsf{Turn Ends} nodes, to avoid having to find them in the tree, whenever a turn begins/ends. The lists of nodes are used to keep all action/defend nodes easily available, again to avoid having to search the entire character node for one specific statement.

The VarLists are used for character specific variables, and AI specific variables. The AI variables are kept here, as an AI is "linked" to one player and therefore will always use that players variables. The VarLists is set up to be searched through in the order:
\begin{itemize}
	\item AI variables
	\item Character variables
	\item Local variables
	\item Global variables
\end{itemize}
The parent pointer is used when the player is initialised, and points back to the environment in the form of the "parent" variable.

\begin{figure}[H]
\centering
\includegraphics[scale=0.25]{img/varlist.png}
\caption{The varlist class. The subclasses overwrite a method in the parent.}
\label{fig:varlist}
\end{figure}

The VarList class is the class actually controlling the different variables, setting and getting the values of them, and checking if the list it contains has a certain variable. Similar to the ``Player'' class the VarList has a parent pointer which in this case, points to either the player that contains it, or nothing if it is contained directly in the environment.

The VarList has two subclasses, PlayerVarList and AIVarList, which is used only to differentiate between the player's character variables and the player's AI variables, so that the order mentioned earlier can be done. \\

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/envclasses.png}
\caption{The relation between classes}
\label{fig:envclasses}
\end{figure}

\subsection*{Semantic analysis}
The first step of the semantic analysis is to split the rules up so that each rule block is found. The blocks Attack Types, Characters, Start, Turn begins and Turn ends are found here, if they are available in the rules. After finding the blocks, they are checked in the order; Attack Types, Start, Turn Begins, Turn Ends and Characters.

This order is used to avoid having to visit certain nodes twice. For example if the characters block were analysed before the attack types, the damage and defend statements would have been checked, without the information of what attack types the rules include, hence they would have to be checked again.

Another example would be the start block, where the global variables are defined. If this block was analysed last, the characters and turn begins/ends nodes would all have to be analysed again, as they would have been analysed based on a scope that (at the time of the original analysis) did not have those global variables available.

The analysis is done by traversing the abstract syntax tree, using a method inherited by all nodes. The effect of this method varies depending on the node, example of this is:
\begin{itemize}
	\item Adding a variable to the environment (assignment)
	\item Setting a pointer in the environment to the node (turn begins/ends nodes among others)
	\item Checking if a variable exists in the current scope (expressions)
\end{itemize}
This method is called ``visit'' and besides some of the earlier mentioned effects, it also invokes all of its children's ``visit'' method. Thereby ensuring that the entire abstract syntax tree is visited.

To facilitate scope checking, a special class is used. This class is only responsible for keeping track of what variables are available at a specific time of checking. A layered approach is used to accomplish this. Whenever a statement that can contain statements are met, a new layer is added to imitate a ``deeper'' scope. For example when an expression is met, the needed variables are checked in this scope class to make sure the variables are accessible from that area of the code. Once the statement, where the layer was added, has finished visiting all of its children, the added layer is removed, and the new variables that was found during the visit, are added to the environment so that it is possible to set and get their values during execution.

The scope class is made in a way so that each layer consists of a parent, a child and a list of variables. This allows access to each outer layer so that if a deep inner layer does not contain a certain variable, it is possible to check in the outer scopes if the variable is available there.

To show an example of how this scope class works, the game ``Knight vs Cat'' in Appendix \ref{app:codeexamples} can be used. In this game there is no start block, therefore there is no global variables, hence the first layer of the scope class has no variables (nor will it ever have a parent layer). The ``view'' is shown in Table \ref{table:scope0}.

\begin{table}[H]
\centering
\begin{tabular}{rl}
\multicolumn{2}{c}{Globals} \\
\hline
Property & Value \\
\hline
Parent & Null \\
Variables & No elements\\
Child & Null \\
\end{tabular}
\caption{Initial Scope View}
\label{table:scope0}
\end{table}

Next would be the turn begins and turn ends nodes, of which the game only has a turn ends.

\begin{lstlisting}[language=KAPAOOW, caption={Knight vs Cat, Turn Ends Code},label=TurnEndSemAnal]
turn ends
	if enemy.HP <= 0 then
		player wins
	end if
end turn
\end{lstlisting}

Once this node is reached in the tree, a new layer is added to the scope. The view now looks like Table \ref{table:scope1}.

\begin{table}[H]
\centering
\begin{tabular}{rl c rl}
\multicolumn{2}{c}{Globals} & & \multicolumn{2}{c}{Turn Ends} \\
\hline
Property & Value & & Property & Value \\
\hline
Parent & Null & & Parent & Globals \\
Variables & No elements & & Variables & No elements\\
Child & Turn ends & & Child & Null\\
\end{tabular}
\caption{Inside Turn Begins}
\label{table:scope1}
\end{table}

Now the first node of the branch is visited, in this case it is an \texttt{if}-node and will check the scope for the needed variables. Here it is \textit{enemy.HP} which is a special character variable, therefore instead of checking if it exists, it is added to the environment as a ``needed'' character variable, which in turn makes it a required variable for all characters.
Upon finishing the visit, the layer is removed again and all variables in the ``variables'' list is added to the environment. However in this case there are no variables to add. The view is once again like Table \ref{table:scope0}.

\begin{table}[H]
\centering
\begin{tabular}{rl}
\multicolumn{2}{c}{Globals} \\
\hline
Property & Value \\
\hline
Parent & Null \\
Variables & No elements\\
Child & Null \\
\end{tabular}
\caption{After Turn Begins}
\label{table:scope2}
\end{table}

The next block to be visited would be the characters block, which has multiple character nodes, each character block is visited one at a time, each going through adding and removing a layer.

The knight character is visited first. The following code is the knight from earlier with a minor change to the action "HealthPotion", the change makes the variable "HP" increase by either 100, 200 or 300 depending on chance.

\begin{lstlisting}[language=KAPAOOW, caption={Knight code},label=KnightSemAnal]
character Knight
	HP = 400
	HealthPotions = 10
	
	action Slap
		damage enemy.HP by 15
		skip turn
	end action
	
	action HealthPotion
		if HealthPotions > 0 then
			Bonus = 1
			random of 6
				1 case
					Bonus = 3
				2 cases
					Bonus = 2
			end random

			HealthPotions = HealthPotions - 1
			HP = HP + 100 * Bonus
		end if
		skip turn
	end action
end character
\end{lstlisting}

The first statements that are met, are 2 assignments in variables \textit{HP} and \textit{HealthPotions}, these variables are added to the list of the layer, and the next statement is checked. The view is now as shown in Table \ref{table:scope3}.

\begin{table}[H]
\centering
\begin{tabular}{rl c rl}
\multicolumn{2}{c}{Globals} & & \multicolumn{2}{c}{Knight} \\
\hline
Property & Value & & Property & Value \\
\hline
Parent & Null & & Parent & Globals \\
Variables & No elements & & Variables & HP\\
 & & & & HealthPotions \\
Child & Knight & & Child & Null\\
\end{tabular}
\caption{Inside Knight}
\label{table:scope3}
\end{table}

The action "Slap" is the next statement, this adds a layer as shown in Table \ref{table:scope4}.

\begin{table}[H]
\centering
\begin{tabular}{rl c rl c rl}
\multicolumn{2}{c}{Globals} & & \multicolumn{2}{c}{Knight} & & \multicolumn{2}{c}{Slap} \\
\hline
Property & Value & & Property & Value & & Property & Value \\
\hline
Parent & Null & & Parent & Globals & & Parent & Knight \\
Variables & No elements & & Variables & HP & & Variables & No elements \\
 & & & & HealthPotions & & \\
Child & Knight & & Child & Slap & & Child & Null \\
\end{tabular}
\caption{Inside Slap}
\label{table:scope4}
\end{table}

The child nodes of the action \textit{Slap} are a \textsf{damage}-node and a \textsf{skip turn}-node.
The first affects \textit{enemy.HP} and will similarly to the earlier turn ends block, add it to the ``needed character variables'' list, although in this case the variable is already there so it is not added again. The second statement does not have anything to do with variables and therefore the scope has no effect on it.

The innermost layer is removed, and the next action ``HealthPotion'' is met, which again adds a layer. Inside this action the first statement is an \texttt{if}-statement which compares \textit{HealthPotions} to 0. In this node the innermost layer is checked for the variable \textit{HealthPotions}. However this layer has the variables for the action ``HealthPotion'', and therefore does not have a variable named \textit{HealthPotions}, upon finding that it does not have the variable, it checks it's parent for whether that layer has a variable named \textit{HealthPotions} and it goes on like that until the parent pointer has a null value. If the null value is reached without finding a variable by the wanted name, an error is thrown stating that the ``needed'' variable is not available in that scope.

Inside the \texttt{if}-statement additional child nodes exists, three assignments and one random.
The first assignment is to a variable named \textit{Bonus}, this is the first time that variable has been seen, and is therefore added to the scopes variable list. The random statement also has 2 assignments depending on the random number, visiting each of these would also add a layer. However since both refer to the already discovered \textit{Bonus} variable, the layers would do nothing, as the scope checking is built to check all previous layers to avoid multiples of the same variable occuring in different scopes. Table \ref{table:scope5} and \ref{table:scope6} shows the view at this point. 

\begin{table}[H]
\centering
\begin{tabular}{rl c rl}
\multicolumn{2}{c}{Globals} & & \multicolumn{2}{c}{Knight}\\
\hline
Property & Value & & Property & Value\\
\hline
Parent & Null & & Parent & Globals \\
Variables & No elements & & Variables & HP \\
 & & & & HealthPotions \\
Child & Knight & & Child & HealthPotion \\
\end{tabular}
\caption{Inside HealthPotion $\rightarrow$ If}
\label{table:scope5}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{rl c rl}
\multicolumn{2}{c}{HealthPotion} & & \multicolumn{2}{c}{If}\\
\hline
Property & Value & & Property & Value\\
\hline
Parent & Knight & & Parent & HealthPotion \\
Variables & No elements & & Variables & Bonus \\
Child & If & & Child & Null \\
\end{tabular}
\caption{Inside HealthPotion $\rightarrow$ If (Continued)}
\label{table:scope6}
\end{table}

After the \texttt{Random} statement another 2 assignments are met, assignment to \textit{HealthPotions} and \textit{HP}. Both assignment nodes immediately adds the assigned variables to the scope. In this case both \textit{HealthPotions} and \textit{HP} exists in the character layer, therefore they are not added.

The \texttt{if}-statement is done, and the innermost layer is removed. During this removal the \textit{Bonus} variable is added to the environment so that during execution the value of it is available. The current view is shown in Table \ref{table:scope7}.

\begin{table}[H]
\centering
\begin{tabular}{rl c rl c rl}
\multicolumn{2}{c}{Globals} & & \multicolumn{2}{c}{Knight} & & \multicolumn{2}{c}{HealthPotion} \\
\hline
Property & Value & & Property & Value & & Property & Value \\
\hline
Parent & Null & & Parent & Globals & & Parent & Knight \\
Variables & No elements & & Variables & HP & & Variables & No elements \\
 & & & & HealthPotions & & \\
Child & Knight & & Child & HealthPotion & & Child & Null \\
\end{tabular}
\caption{After If}
\label{table:scope7}
\end{table}

The \texttt{skip turn} statement has no effect on the scope. The action is completed and another layer is removed as shown in Table \ref{table:scope8}.

\begin{table}[H]
\centering
\begin{tabular}{rl c rl}
\multicolumn{2}{c}{Globals} & & \multicolumn{2}{c}{Knight}\\
\hline
Property & Value & & Property & Value\\
\hline
Parent & Null & & Parent & Globals \\
Variables & No elements & & Variables & HP \\
 & & & & HealthPotions \\
Child & Knight & & Child & Null \\
\end{tabular}
\caption{After HealthPotion}
\label{table:scope8}
\end{table}

Finally the knight character is complete and another layer is removed, causing the scope to end up as before checking the knight character. As with the \textit{Bonus} variable, the \textit{HP} and \textit{HealthPotions} variables are added to the environment, the view has ended up as it was in Table \ref{table:scope0}:

\begin{table}[H]
\centering
\begin{tabular}{rl}
\multicolumn{2}{c}{Globals} \\
\hline
Property & Value \\
\hline
Parent & Null \\
Variables & No elements\\
Child & Null \\
\end{tabular}
\caption{After Knight}
\label{table:scope9}
\end{table}

The scope checking of the \textit{Knight} is now complete as there is no more children to check in the that block, a similar walkthrough would occur with the character \textit{Cat}, and afterwards, the characters block (and the game) has been scope checked.

After analysing the entire tree, each character is checked again. This check includes checking for actions with the same name, so that during execution an action name cannot refer to two different actions, and similarly the defend nodes are checked to make sure there are no defends defending the same variable from the same attack type. This is also where the character variables are checked to make sure all characters have variables accessed through the \texttt{enemy.} keyword.