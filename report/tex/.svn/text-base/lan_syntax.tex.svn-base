\section{Syntax} \label{sec:languagesyntax}
All languages, whether they are artificial like programming languages or real such as English or Danish, are a set of strings of characters from some alphabet, these strings are called sentences or statements. The syntax rules of a programming language specify the set of characters from the language's alphabet that are allowed to be used in the language, this is also called a \textit{grammar}.

This section is based on the book "Concepts of Programming Languages" chapter 3 and explains the theory for syntax of a programming language \cite{conceptbog}.

\subsection*{Context-Free Grammars}
A context-free grammar is a set of production rules used to generate strings.\\
Figure \ref{fig:cfg} shows a simple example of a context free grammar (CFG): 
\begin{figure}[H]
\centering
\begin{tabular}{l r l}
S & $\ra$ & AB\\
& $|$ & ASB\\
A & $\ra$ & a\\
B & $\ra$ & b
\end{tabular}
\caption{Simple context free grammar}
\label{fig:cfg}
\end{figure}
A CFG has two different kinds of symbols in its grammar: terminal symbols and non-terminal symbols. In the grammar above, the terminal symbols are \textit{a} and \textit{b} and the non-terminal symbols are \textit{S}, \textit{A} and \textit{B}. A terminal symbol can never occur on the left hand side (LHS), but non-terminals may occur on the right hand side (RHS) as well as the LHS. 

A CFG consists of a number of rules, which allows us to rewrite the start symbol S to other strings. The rules are used by replacing an occurrence of a non-terminal symbol on the RHS, with the non-terminal's rule. An example of this can be seen in Figure \ref{fig:derivation}. \citep{cfg}
\begin{figure}[H]
\centering
\begin{tabular}{l l}
S & \\
ASB & Rule 2\\
AABB & Rule 1\\
aABB & Rule 4\\
aaBB & Rule 4\\
aabB & Rule 3\\
aabb & Rule 3
\end{tabular}
\caption{Derivation of the string aabb}
\label{fig:derivation}
\end{figure}
A sequence like the one shown on Figure \ref{fig:derivation} is called a \textit{derivation}. There are two strategies when determining the next non-terminal to rewrite: leftmost derivation or rightmost derivation. The example in Figure \ref{fig:derivation} uses a leftmost derivation, meaning it is always the leftmost non-terminal that gets rewritten and with rightmost derivation it is always the rightmost non-terminal that gets rewritten.

\subsection*{Backus-Naur Form}
Backus-Naur Form (BNF) is a notation for a CFG and it is a useful tool when having to describe a programming language. BNF uses abstractions for syntactic structure.

For example a simple assignment in Java can be represented by the abstraction $<$\texttt{assign}$>$ (pointed brackets are used to delimit names of abstractions). The actual definition of $<$\texttt{assign}$>$ can be given by:
\begin{center}
$<$\texttt{assign}$>$\ $\rightarrow$\ $<$\texttt{var}$>$\ $=$ $<$\texttt{expression}$>$
\end{center}
The symbol on the LHS of the arrow, is the abstraction being defined. The text on the RHS consists of a mixture of terminals and references to other abstractions, an example of the rule in action could be
$$\texttt{total = subtotal1 + subtotal2}$$
This rule for an assignment specifies that the abstraction $<$\texttt{assign}$>$  is defined as an instance of the abstraction $<$\texttt{var}$>$, then followed by the symbol $=$, which is followed by an instance of the abstraction $<$\texttt{expression}$>$\\
The most common way of defining a rule is:
\begin{center}
$<$\texttt{non-terminal}$>$ $\rightarrow$\ $<$\texttt{terminal}$>$
\end{center}
A non-terminal can have several distinct definitions, this can be written as a single rule by separating the definitions with the symbol $|$ .

Even though a BNF is simple, it is a very powerful tool when describing the syntax for a programming language.



\subsection*{Extended BNF}
The BNF notation has been extended in several ways, however the extensions do not enhance the descriptive power of a BNF, it merely makes it more readable and writable. There are three common extensions for the EBNF. The first one denotes an optional part of an RHS by using square brackets "[ ]", an example of this is an \texttt{If-else}-statement in Java, using the normal BNF notation this would be described as:\\\\
\begin{tabular}{r r l}
$<$\texttt{if}\_\texttt{stmt}$>$ & $\rightarrow$ & \texttt{if}$(\ <$\texttt{expression}$>\ )$\ $<$\texttt{stmt}$>$\\
& $|$ & \texttt{if}$(\ <$\texttt{expression}$>\ )$ $<$\texttt{stmt}$>$ \texttt{else}\ $<$\texttt{stmt}$>$
\end{tabular}\\\\
Using an EBNF it is possible to describe this with only one rule:\\\\
\begin{tabular}{r r l}
$<$\texttt{if}\_\texttt{stmt}$>$ & $\rightarrow$ & \texttt{if}$(\ <$\texttt{expression}$>\ )$ $<$\texttt{stmt}$>$ $[$\ \texttt{else} $<$\texttt{stmt}$>\ ]$
\end{tabular}\\\\
The second extension is the use of the Kleene cross "$^+$" to indicate one or more occurrences of an element and the Kleene star "$^\ast$" to indicate zero or more occurrences of an element\cite{kleene}:\\\\
\begin{tabular}{r r l}
$<$\texttt{if}\_\texttt{stmt}$>$ & $\rightarrow$ & \texttt{if}$(\ <$\texttt{expression}$>\ )$ $<$\texttt{stmt}$>$ \\
& & \indent $\hookrightarrow$ $($\ \texttt{else if} (\ $<$\texttt{expression}$>$\ )\ $<$\texttt{stmt}$>\ )^\ast$ $[$\texttt{else}$]$
\end{tabular}\\\\
The Kleene star indicates that the \texttt{else if $<$stmt$>$} can be repeated zero or more times.
The third common extension is when a rule has more than one option, for example if there are different operators:\\\\
\begin{tabular}{r r l}
$<$\texttt{term}$>$ & $\rightarrow$ & $<$\texttt{term}$>$ \texttt{$($ $^\ast$ $|$ $/$ $|$ $\%$ $)$} $<$\texttt{factor}$>$
\end{tabular}\\\\
The three options are placed in parentheses separated by the \texttt{OR} operator "$|$". If this description of the $<$\texttt{term}$>$ was to be described in a normal BNF it would require three rules:\\\\
\begin{tabular}{r r l}
$<$\texttt{term}$>$ & $\rightarrow$ & $<$\texttt{term}$>$ $\ast$ $<$\texttt{factor}$>$\\
& $|$ & $<$\texttt{term}$>$ $/$ $<$\texttt{factor}$>$\\
& $|$ & $<$\texttt{term}$>$ $\%$ $<$\texttt{factor}$>$ 
\end{tabular}

\subsection*{Ambiguity}
If the grammar is ambiguous the same sentence has more than one distinct parse trees, i.e. the sentence has two or more different leftmost derivations. An example of an ambiguous and an unambiguous grammar for a simple assignment statement can be seen on Figure \ref{fig:grammar}. 
\begin{figure}[H]
\centering
\subfloat[Ambiguous grammar]
{
\begin{tabular}{l r l}
$<$\texttt{assign}$>$ & $\rightarrow$ & $<$\texttt{id}$>$ $=$ $<$\texttt{expr}$>$\\
$<$\texttt{id}$>$ & $\rightarrow$ & \texttt{A $|$ B $|$ C}\\
$<$\texttt{expr}$>$ & $\rightarrow$ & $<$\texttt{expr}$>$ $+$ $<$\texttt{expr}$>$\\
& $|$ & $<$\texttt{expr}$>$ $\ast$ \texttt{expr}$>$\\
& $|$ & $(\ <$\texttt{expr}$>\ )$\\
& $|$ & $<$\texttt{id}$>$ 
\end{tabular}
}
\subfloat[Unambiguous grammar]
{
\begin{tabular}{l r l}
$<$\texttt{assign}$>$ & $\rightarrow$ & $<$\texttt{id}$>$ $=$ $<$\texttt{expr}$>$\\
$<$\texttt{id}$>$ & $\rightarrow$ & \texttt{A $|$ B $|$ C}\\
$<$\texttt{expr}$>$ & $\rightarrow$ & $<$\texttt{expr}$>$ $+$ $<$\texttt{term}$>$\\
& $|$ & $<$\texttt{term}$>$\\
$<$\texttt{term}$>$ & $\rightarrow$ & $<$\texttt{term}$>$ $\ast$ $<$\texttt{factor}$>$\\
& $|$ & $<$\texttt{factor}$>$ $\ast$ $<$\texttt{expr}$>$\\
$<$\texttt{factor}$>$ & $\rightarrow$ & $(\ <$\texttt{expr}$>\ )$\\
& $|$ & $<$\texttt{id}$>$ 
\end{tabular}
}
\caption{An ambiguous and an unambiguous grammar}
\label{fig:grammar}
\end{figure}
If a language is ambiguous, the structure has more than one leftmost derivation. This is a problem because an interpreter examines the parse tree to generate the code needed for the given statement. Figure \ref{fig:ambiguiousparsetree} shows that the ambiguous grammar in Figure \ref{fig:grammar} can create two different parse trees for the assignment \texttt{A $=$ B $+$ C $*$ A}. The ambiguity in this case is based on a operator precedence problem.

\begin{figure}[H]
\centering
\includegraphics[width=1.0\linewidth]{img/ambiguiousparsetree.png}
\caption{Two different parse tree for the sentence \texttt{A $=$ B $+$ C $*$ A.}}
\label{fig:ambiguiousparsetree}
\end{figure}
