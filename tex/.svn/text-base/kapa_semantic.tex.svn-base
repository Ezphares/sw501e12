\pagebreak
\section{Semantics for KAPAOOW}\label{sec:kapaSemantics}
The reader is urged to be familiar with operational semantics and the environment-store model which is explained in Section \ref{sec:semantics}.

\subsection*{Syntactic categories}

\begin{table}[h]
\centering
\begin{tabular}{c}
\end{tabular}
\begin{tabular}{r c l l}
\hline
$n$ & $=$ & $\backslash \textbf{n}$ & Newline\\
$u$ & $\in$ & $\textbf{Ulet}$ & Unicode letters\\
$r$ & $\in$ & $\textbf{Rnum}$ & Real numbers\\
$x$ & $\in$ & $\textbf{Var}$ & Variables\\
$a$ & $\in$ & $\textbf{Aexp}$ & Arithmetic expressions\\
$b$ & $\in$ & $\textbf{Bexp}$ & Boolean expressions\\
$S$ & $\in$ & $\textbf{Stm}$ & Statements\\
$t$ & $\in$ & $\textbf{Atyp}$ & Attack types\\
\hline
\end{tabular}
\end{table}

\begin{description}
\item[Ulet] is the set of unicode letters.
\item[Rnum] is the set of real numbers.
\item[Var] is the set of variables where $\textbf{Var} = \textbf{Ulet}^+$.
\item[Atyp] is the set of attack types where $\textbf{Atyp} = \textbf{Ulet}^+$.
\item[Aexp/Bexp/Stm] the same as expressions, boolean expressions, and statements in Section \ref{sec:kapaSyntax}.
\end{description}

\subsection*{Environments}

A game consists of two participants playing. Each player have their own set of variable environment so we need a definition for both of them:
$$\textbf{EnvV}_1 = \textbf{Var} \cup \{ \texttt{next} \} \rightharpoonup \textbf{Loc}$$
$$\textbf{EnvV}_2 = \textbf{Var} \cup \{ \texttt{next} \} \rightharpoonup \textbf{Loc}$$
We need an attack type environment \textbf{EnvT} that consists of the different attack types that is used in the game:
$$\textbf{EnvT} = \textbf{Atyp} \cup \{ \texttt{next} \} \rightharpoonup \textbf{Loc}$$
Both participants need action environments \textbf{EnvA} and defend environments \textbf{EnvD}, because we need to know the \textit{actions} and the \textit{defends} that is used in the game:
$$\textbf{EnvA} = \textbf{Anames} \rightharpoonup \textbf{Stm} \times \textbf{EnvV}_1 \times \textbf{EnvV}_2$$
$$\textbf{EnvD} = \textbf{Chars} \rightharpoonup \textbf{Stm} \times \textbf{EnvV}_1 \times \textbf{EnvV}_2$$
The set of stores is the set of partial functions from locations to values
$$\textbf{Sto} = \textbf{Loc} \rightharpoonup \textbf{Rnum}$$
We will write arbitrary elements in the environments with lower case letters, such that: $env_{V_1} \in \textbf{EnvV}_1$, $env_{V_2} \in \textbf{EnvV}_2$, $env_T \in \textbf{EnvT}$, $env_A \in \textbf{EnvA}$, and $env_D \in \textbf{EnvD}$.



\subsection*{Operational semantics}
We have chosen not to write operational semantics of the entire language KAPAOOW. We describe \texttt{from} loops, \texttt{damage} statements, \texttt{defend} statements, and \texttt{random-case} statement.

We use $i$ to keep track of whose turn it is, because the players have different variable environments. To shorten the lines and the section we assume some syntax for this section:
\begin{itemize}
\item We use the notation $[\,]$ where everything in between the square brackets is optional.
\item $n$ is a \textit{newline}, but because it is optional how many \textit{newlines} can be written, we assume that $n$ is one or more newlines; $n = n^+$.
\item All statements $S$ may consist of 0 or more statements where each statement is followed by a newline; $(S n)^*$.
\end{itemize}

Table \ref{tab:damdef} shows the operational semantics for \textit{damage} and \textit{defend} statements. $[\texttt{DAMAGE1}]$ is the rule that subtracts the amount of damage $a_1$ from $x_1$. $[\texttt{DAMAGE2}]$ is the rule that attempts to damage but is stopped by the \textit{defend} statement that defends $x_2$ if $t_1 = t_2$ and $x_1 = x_2$. This means that $[\texttt{DAMAGE2}]$ does nothing but pass damage on to $[\texttt{DEFEND}]$ and leaves it up to the \textit{defend} statement to handle the damage.

\begin{table}[H]
\small
\begin{align*}
&[\texttt{DAMAGE1}] && \frac{env_{V_1},env_{V_2},env_D,env_T \vdash \langle x_1 = a_2,sto,i \rangle \rightarrow sto[x_1 \rightarrow v_2]}{env_{V_1},env_{V_2},env_D,env_T \vdash \langle \texttt{damage} \: x_1 \: \texttt{by} \: a_1 \: [\texttt{using} \: t_1],sto,i \rangle \rightarrow sto,i}\\
&&& \textsf{where} \: sto \vdash a_1 \rightarrow v_1\\
&&& sto \vdash x_1 - v_1 \rightarrow v_2
\\\\
&[\texttt{DAMAGE2}] && \frac{env_{V_1},env_{V_2},env_A,value,env_T \vdash \langle \texttt{defend} \: x_2 \: \texttt{from} \: t_2 \: n \: S_1 \: \texttt{end defend}, sto,i \rangle \rightarrow sto',i}{env_{V_1},env_{V_2},env_D,env_T \vdash \langle \texttt{damage} \: x_1 \: \texttt{by} \: a_1 \: [\texttt{using} \: t_1],sto,i \rangle \rightarrow sto,i}\\
&&& \textsf{if} \: env_T,sto',i \vdash t_1 = env_T,sto',i \vdash t_2\\
&&& \texttt{and} \: env_{V_1},env_{V_2},sto',i \vdash x_1 = env_{V_1},env_{V_2},sto',i \vdash x_2 \rightarrow \textit{true} 
\\\\
&[\texttt{DEFEND}] && \frac{env_{V_1},env_{V_2},env_A,value,env_T \vdash \langle S_1,sto,i \rangle \rightarrow sto',i}{env_{V_1},env_{V_2},env_A,value,env_T \vdash \langle \texttt{defend} \: x_1 \: \texttt{from} \: t_1 \: n \: S_1 \: \texttt{end defend}, sto,i \rangle \rightarrow sto',i}\\
&&& \textsf{if} \: env_{V_1},env_{V_2},sto',i \vdash t_1 = env_{V_1},env_{V_2},sto',i \vdash t_2 \rightarrow \textit{true}
\end{align*}
\caption{Operational semantics for \textsf{damage} and \textsf{defend}}
\label{tab:damdef}
\end{table}

\pagebreak
Table \ref{tab:fromloops} shows the operational semantics for \textit{from-loops}. Each iteration can either in- or decrement (\textit{to} or \textit{downto}) which determines how many iterations there is. The amount in- or decrementing depends on whether \textit{jump $a_3$} was written or not.

\begin{table}[H]
\small
\begin{align*}
&\left[ \begin{array}{c}\texttt{FROM-}\\\texttt{TO-}\\\texttt{TRUE} \end{array}\right] && \frac{\begin{array}{l}env_{V_1},env_{V_2},env_A,env_T \vdash \langle S_1,sto,i\rangle \rightarrow sto',i\\
env_{V_1},env_{V_2},env_A,env_T \vdash \langle \texttt{from} \: a_1 \: \texttt{to} \: a_2 \: [\texttt{jump} \: a_3] \: \texttt{do} \: n \: S_1 \: \texttt{next},sto',i\rangle \rightarrow sto'',i,i\end{array}}{env_{V_1},env_{V_2},env_A,env_T \vdash \langle \texttt{from} \: a_1 \: \texttt{to} \: a_2 \: [\texttt{jump} \: a_3] \: \texttt{do} \: n \: S_1 \: \texttt{next}, sto,i \rangle \rightarrow sto'',i}
\\ &&& \textsf{where} \: env_{V_1},env_{V_2},env_T,sto',i \vdash a_1 \rightarrow v_1
\\ &&& \textsf{where} \: env_{V_1},env_{V_2},env_T,sto',i \vdash a_2 \rightarrow v_2
\\ &&& \textsf{if} \: v_1 < v_2 \rightarrow true
\\ &&& a_1 = a_1 + r_1
\\ &&& \textsf{where} \: r_1 = 1 \: \texttt{or} \: r_1 = a_3
\\\\
&\left[ \begin{array}{c}\texttt{FROM-}\\\texttt{TO-}\\\texttt{FALSE} \end{array}\right] && \begin{array}{l} env_{V_1},env_{V_2},env_A,env_T \vdash \langle \texttt{from} \: a_1 \: \texttt{to} \: a_2 \: [\texttt{jump} \: a_3] \: \texttt{do} \: n \: S_1 \: \texttt{next}, sto,i \rangle \rightarrow sto,i
\\\\ \textsf{where} \: env_{V_1},env_{V_2},env_T,sto',i \vdash a_1 \rightarrow v_1
\\ \textsf{where} \: env_{V_1},env_{V_2},env_T,sto',i \vdash a_2 \rightarrow v_2
\\ \textsf{if} \: v_1 < v_2 \rightarrow false \end{array}
\\\\
&\left[ \begin{array}{c}\texttt{FROM-}\\\texttt{DOWNTO-}\\\texttt{TRUE} \end{array}\right] && \frac{\begin{array}{l}env_{V_1},env_{V_2},env_A,env_T \vdash \langle S_1,sto,i\rangle \rightarrow sto',i\\
env_{V_1},env_{V_2},env_A,env_T \vdash \langle \texttt{from} \: a_1 \: \texttt{downto} \: a_2 \: [\texttt{jump} \: a_3] \: \texttt{do} \: n \: S_1 \: \texttt{next},sto',i\rangle \rightarrow sto'',i,i\end{array}}{env_{V_1},env_{V_2},env_A,env_T \vdash \langle \texttt{from} \: a_1 \: \texttt{downto} \: a_2 \: [\texttt{jump} \: a_3] \: \texttt{do} \: n \: S_1 \: \texttt{next}, sto,i \rangle \rightarrow sto'',i}
\\ &&& \textsf{where} \: env_{V_1},env_{V_2},env_T,sto',i \vdash a_1 \rightarrow v_1
\\ &&& \textsf{where} \: env_{V_1},env_{V_2},env_T,sto',i \vdash a_2 \rightarrow v_2
\\ &&& \textsf{if} \: v_1 > v_2 \rightarrow true
\\ &&& a_1 = a_1 - r_1
\\ &&& \textsf{where} \: r_1 = 1 \: \texttt{or} \: r_1 = a_3
\\\\
&\left[ \begin{array}{c}\texttt{FROM-}\\\texttt{DOWNTO-}\\\texttt{FALSE} \end{array} \right] && \begin{array}{l} env_{V_1},env_{V_2},env_A,env_T \vdash \langle \texttt{from} \; a_1 \; \texttt{downto} \; a_2 \; [\texttt{jump} \; a_3] \; \texttt{do} \: n \: S_1 \: \texttt{next}, sto,i \rangle \rightarrow sto,i
\\\\ \textsf{where} \: env_{V_1},env_{V_2},env_T,sto',i \vdash a_1 \rightarrow v_1
\\ \textsf{where} \: env_{V_1},env_{V_2},env_T,sto',i \vdash a_2 \rightarrow v_2
\\ \textsf{if} \: v_1 > v_2 \rightarrow false \end{array}
\end{align*}
\caption{Operational semantics for \textsf{from} loops}
\label{tab:fromloops}
\end{table}

\pagebreak
Table \ref{tab:random} shows the operational semantics for \textit{random} statements. [\texttt{CASE}] uses $a_2$ from [\texttt{RANDOM}] to randomly choose a case to be run. The random number $a_2$ is subtracted with $a_1$ which is the case value. If $a_2$ is less than or equal to 0 then the current case is run. If $a_2$ never goes below 0, then the else case is run.

To receive a random number in our semantics we define a function $\mathbb{R}(a_1)$ that returns a random number greater than or equal to 0 and less than $a_1$:
$$\mathbb{R}(a_1) = a_2 \qquad \texttt{where} \; 0 \leq a_2 < a_1$$

\begin{table}[H]
\small
\begin{align*}
&[\texttt{RANDOM}] && \frac{\begin{array}{l}
\langle a_2, sto, i \rangle \rightarrow sto', i \\
\langle S_1, sto', i \rangle \rightarrow sto'', i \end{array}} {env_{V_1},env_{V_2},env_A,env_T \vdash \langle \texttt{random of} \: a_1 \: n \: [\texttt{CASE}]^* \: [\texttt{ELSE}_\texttt{CASE}] \: \texttt{end random},sto',i \rangle \rightarrow sto'',i}\\
&&& \textsf{where} \: sto \vdash a_2 \rightarrow v_1\\
&&& \textsf{where} \: v_1 = \mathbb{R}(a_1)
\\\\
&[\texttt{CASE}] && \frac{\begin{array}{l}env_{V_1},env_{V_2},env_A,env_T,sto \vdash \langle \texttt{while} \: b_1 \: \texttt{do} \: S_2 \: \texttt{loop}, sto,i \rangle \rightarrow sto',i\\
env_{V_1},env_{V_2},env_A,env_T,sto \vdash \langle S_1, sto',i \rangle \rightarrow sto'',i\end{array}}{env_{V_1},env_{V_2},env_A,env_T,sto \vdash \langle a_1 \: \texttt{case} \: n \: S_1, sto',i \rangle \rightarrow sto'',i}\\
&&& \textsf{where} \: S_2 = \quad a_2 = a_2 - a_1\\
&&& \textsf{where} \: b_1 = a_2 > 0\\
&&& \textsf{if} \: a_2 <= 0 \rightarrow true \: \texttt{or} \: \texttt{ELSE-CASE} \rightarrow true
\\\\
&\left[ \begin{array}{c}\texttt{ELSE-}\\\texttt{CASE} \end{array}\right] && \frac{env_{V_1},env_{V_2},env_A,env_T \vdash \langle S_1, sto,i \rangle \rightarrow sto',i}{env_{V_1},env_{V_2},env_A,env_T \vdash \langle \texttt{else} \: n \: S_1, sto,i \rangle \rightarrow sto',i}
\end{align*}
\caption{Operational semantics for \textsf{random}}
\label{tab:random}
\end{table}
