\pagebreak
\section{Semantics}\label{sec:semantics}
The semantics describes how a program behaves when it is executed, i.e the behaviour of a program. This section explains the theory for semantics, and it is based on the books "Concepts of Programming Languages" Chapter 3, and "Transitions and Trees" , Chapter 1-3 and 6 \citep{conceptbog,semantikbog}.

\subsection*{Structural operational semantics}
The basic idea of structural operational semantics is to define how a program behaves by describing the behaviour of its parts. Structural operational semantics specifications describes the program behaviour with a set of transition rules. The rules define valid transitions of a composite piece of syntax in terms of the transitions of its components. 

\begin{figure}[H]
\centering
\begin{tabular}{r r l}
\texttt{a} & $::=$ & \texttt{$a_1 + a_2$}\\
& $|$ & \texttt{$a_1 * a_2$}\\
& $|$ & \texttt{x}
\end{tabular}
\caption{Small example of an abstract syntax}
\label{fig:smallsyntax}
\end{figure}
Figure \ref{fig:smallsyntax} shows a small example of an abstract syntax for the arithmetical expression $a$, the example states that an arithmetical expression can be either the sum or the multiplication of two other arithmetical expressions or it can be a number $x$.

Figure \ref{fig:semrules} shows the semantical rules for adding and multiplication for the small language defined in Figure \ref{fig:smallsyntax}.\\
The line $a_1 \ra_a v_1$ is read as $a_1$ \textit{evaluates} to $v_1$, where $a_1$ is a arithmetical expression and $v_1$ is a variable. These rules are also called transition systems. These transitions can be used to describe the behaviour of the programming language. 
\begin{figure}[H]
\centering
\begin{tabular}{ccccc}
	\( \left[ \text{Add} \right] \) & \( \quad \) & \( \displaystyle\frac{a_1 \rightarrow_{a} \nu_1 \ a_2 \rightarrow_{a} \nu_2}{a_1 + a_2 \rightarrow_{a} \nu} \) & \( \quad \) & \( where \quad \nu = \nu_1 + \nu_2 \) \\ \\
	\( \left[ \text{Multi} \right] \) & \( \quad \) & \( \displaystyle\frac{a_1 \rightarrow_{a} \nu_1 \ a_2 \rightarrow_a \nu_2}{a_1*a_2 \rightarrow_a \nu} \) & \( \quad \) & \( where \quad \nu = \nu_1*\nu_2 \)
\end{tabular}
\caption{Structural operational semantic rules.}
\label{fig:semrules}
\end{figure}

\subsection*{Environment-store Model}
The environment-store model describes how variables are stored during a program execution. Each variable is bound to a location, and the content of a location is the value of the variable.

The \textit{variable environment} is a function that for each variable tells us to which location it is bound. The \textit{store} is a function that for each storage location tells us which value is found at the location. This enables the language to support variable references.

Figure \ref{fig:envsto} shows an illustration of the environment-store model. In this example we have a variable environment that is the set of partial functions from variables to locations:
$$\textbf{EnvV} = \textbf{Var} \cup \{ \texttt{next} \} \rightharpoonup \textbf{Loc}$$
and we have the set of stores that is a set of partial functions from locations to values:
$$\textbf{Sto} = \textbf{Loc} \rightharpoonup \mathrm{Z}$$
$env_V$ is an arbitrary element of $\textbf{EnvV}$ and $sto$ is an arbitrary element of $\textbf{Sto}$.
\begin{figure}[h]
\centering
\includegraphics[width=1\linewidth]{img/envstomod.png}
\caption{Envrionment-store Model}
\label{fig:envsto}
\end{figure}
In $\textbf{Var} \cup \{ \texttt{next} \}$ we have three variables $a$, $b$, and $c$, but there is also $\{ \texttt{next} \}$. $\{ \texttt{next} \}$ is a pointer to the next available location. The variable $a$ is bound to location $l_1$, and the variables $b$ and $c$ are both pointing to the same location, $l_2$.  No other variables are bound to any location. The next free location is $l_3$. The content of location $l_1$ is 400, and the content of location $l_2$ is 1337. The content of all other locations are undefined.